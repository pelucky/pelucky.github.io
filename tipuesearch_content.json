{"pages":[{"url":"https://pelucky.github.io/pages/2016/03/31/git-talk/","text":"每次碰到Git的问题都要去Google，索性整理记录下，基本的安装和使用就不介绍了... 0x01 Basic Git是创建快照而不是记录不同： 传统VCS的存储方式： 0x02 Git storage Git的存储方式导致Git类似一个文件系统，在创建Git分支的时候非常有用； Git是一个分布式代码管理软件，故每个git端上都会保存完整的所有版本的代码，故在本地端就会有一个代码的副本，故可以在本地进行操作； Git存在完整性校验； Git通常只添加数据，而不会抹除数据，避免了代码丢失的风险； 0x03 Git state 三个状态： committed, modified, staged Committed表示已经安全的存储在本地； Modified表示已经修改但是还没有提交commit存储到本地数据库中； Staged表示标志了modified文件在当前的版本将会提交到下次创建快照中； 下图描述了git的通常工作流程： Modified文件； staged文件，添加他们的快照到staging area； 将staging area中的文件添加到本地git数据库中； 0x04 Setup & usage 安装和配置git直接参照书或git笔记的说明即可； 子目录中git的配置会覆盖全局配置； 文件的状态有两类：tracked和untracked，tracked又分为上面说的三种； gitignore文件的语法详见 第二章 ； git config #配置用户名和邮箱以及默认的编辑器 git config --list #列出配置参数 git help XXX #查找帮助 git remove #会将tracked file列表和实际存在的本地文件统统删除，如果只想不追踪，可以使用gitignore或者git rm --cached XXX git mv #移动文件而不会重新记录 git log -p #显示每次提交的不同地方。log中还有很多参数可以选择； git commit --amend #在提交漏交文件之后只提交一次commit，而不会有两次； git reset HEAD <file> #可以将staged文件设置为unstaged文件; git checkout -- [file] #是一个危险命令，可以将文件还原为未修改状态；他的工作原理是将老的文件直接覆盖掉新的文件，故会将所做的修改抹去； git的生命周期为： Tips: untracked files为未添加跟踪的文件状态,即未git add xxxx.xx的文件; 添加跟踪未被修改的文件状态为Unmodified，即经过上次的git commit之后未修改的文件; Changes not staged for commit: (modified)为添加跟踪且被修改过的文件状态 Changes to be committed为添加跟踪且被修改过并被提交到暂存区的(也就是图上的staged)，可通过git add命令将文件添加到暂存区； git add是个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为\"添加内容到下一次提交中\"而不是\"将一个文件添加到项目中\"要更加合适。 复原文件 的方法，恢复到Modified之前的文件; # 在文件被Modified但是未被staged的前提下，可使用checkout放弃对该文件的修改 git checkout xxx.xx 查看 git的存储文件目录； .git是个隐藏文件夹，包含在项目目录下； .git/objects下是2个字母的若干文件夹，分别代表了每个sha1 hash的前两位； .git/objects/ 的下为38位的文件，为objects的压缩并编码值； .git/config为该项目的配置文件 .git/refs/xxx下有heads和tags文件夹，heads表示现在使用的分支，tags表示tag的版本号 0x05 Remote git remote #查看配置了的远端服务器的参数，-v可以查看详细信息; git remote add [shortname] [url] #显式的添加配置信息; git fetch [remote-name] #会将从远端的数据拉过来，但是不会主动合并，pull则会主动合并；（此处的remote-name就是git remote中显示出来的参数） git push [remote-name] [branch-name] #会将code推送到相对应的分支上去；当然同时只能有一个人正在push；如果别人push完毕后，由于代码的不一致，你需要先pull下别人的代码，才能push上去; git push origin master --force #强行push，Dangerous！ git remote show [remote-name] #会展示远端服务器的情况，包括远端服务器的分支有哪些还未被同步，有哪些可以合并等； git remote rename [old-name] [new-name] #修改远端的名称； git remote rm [name] #删除一个远端 0x06 Tag Git中有两种tag， 轻量级tag 和 带注释的tag ； 轻量级tag像一个不会改变的分支，只适用于特殊的标记；带注释的tag则五脏俱全； git tag #使用tag来标记版本，-l可以搜索关键字tag； git tag -a v1.4 -m 'my version 1.4' #-m提示书写注释信息，如同commit中的-m，-a表示添加annotated tags git tag v1.4-lw #轻量级tag git tag -a v1.2 9fceb02 #支持对之前的版本添加tag，方法是记住加上校验码的部分（如9fceb02就是某个版本校验码的前7位） git push origin v1.5 #默认git push 是不会将tag上传到服务器端的，如果需要可以使用 git push origin --tags #一次性上传所有的tags Git alias 可以在全局模式下设置别名，故可以使用git 别名，如： git config --global alias.unstage 'reset HEAD --' 如下两个等价： $ git unstage fileA $ git reset HEAD -- fileA 或者直接修改配置文件~/.gitconfig [alias] hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short 0x07 Branching 参考 ：很详细的讲解了git branch的过程； Notice ： 添加分支不会主动修改HEAD的指向； git的快照是采用指针的方式，每个指针指向其\"母版本\"； 由于是存储快照，故在创建分支是非常迅速的，每个只需要增加41bytes（40字节的校验码和一个空行），不会像其他VCS那样存储一个副本，节省了时间； 与其他VCS不同，他不需要用户选择更倾向于哪个分支，而会将他们两个选择为共同的祖先，也就是同时指向他们两个； 未经merge的分支是不建议删除的，如果需要强制删除，需要使用-D； 记住merge和branch都是在本地，没有与远端的服务器通信； git branch [ branch name ] #创建一个新分支 git checkout [ branch name ] #选择一个分支 git checkout - b [ branch name ] #等同于上面两个操作 git merge [ branch name ] #将老分支与之前的 snapshot 合并（要 checkout 一个分支， merge 另一个分支） git branch - d [ branch name ] #删除某个 branch 分支（这里个人理解为删除某个快照名） git mergetool #当某个文件被两个分支同时修改过时， merge 他就会有冲突，可以手动修改冲突之后，在进行合并；也可使用图形工具 ( 需要实现配置，使用 opendiff ) : git branch #查看现在所处的分支， - v 查看详细内容； -- merged 查看合并的内容； git ls - remote ( remote ) #查看远端服务器分支情况 git remote show ( remote ) 远端的分支采用(remote)/(branch)的形式，如origin/master表示远端master的位置； 常用名origin不是固定的，可以修改； remote branch还有很多货，不是很理解，以后再过一遍! 0x08 rebase rebase（中文翻译变基）的作用就是将提交到某一个分支的所有操作用到另一个上去；也就是将两个分支合并为一个分支； 选中一个分支，然后将另一个分支变基过来… 变基的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 git checkout experiment git rebase master git checkout master git merge experiment 不要对在你的仓库外有副本的分支执行变基，因为会造成混乱 merge vs rebase 翻译里面说的：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作. merge不会改变历史记录，使用merge会记录实际发生过的内容；rebase则会修改历史记录，如果你认为提交历史是项目过程中发生的故事，则使用rebase更合适； 0x09 Distributed Git 分布式工作流程大致可以分为三类：集中式工作流、集成管理者工作流和司令官与副官工作流； 集中式工作流 集中式系统中通常使用的是单点协作模型——集中式工作流。 一个中心集线器，或者说仓库，可以接受代码，所有人将自己的工作与之同步。 若干个开发者则作为节点——也就是中心仓库的消费者——并且与其进行同步。 这是最常用的工作流。多人合作项目时，要求后人将前人数据抓取下来并且合并后才能推送到中心仓库中，即是非快进式（non-fast-forward）的方式推送 集成管理者工作流 Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表\"官方\"项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示： 项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 司令官与副官工作流 般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。 被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。 所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。 司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。 整个流程看起来是这样的: 普通开发者在自己的特性分支上工作，并根据 master 分支进行变基。 这里是司令官的master分支。 副官将普通开发者的特性分支合并到自己的 master 分支中。 司令官将所有副官的 master 分支并入自己的 master 分支中。 司令官将集成后的 master 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。 实际并不常用，只有像Linux内核这类的大项目才会用到... 0x0A Contributing to a project 两个开发者编辑了不同的文件时，Subversion 会对编辑的不同文件在服务器上自动进行一次合并，但 Git 要求你在本地合并提交。 一个简单的多人 Git 工作流程的通常事件顺序 0x0B One step to Github apt-get install git 生成SSH-key ， ssh-keygen -t rsa -C \"your_email@youremail.com\" ，your_email是你的email，默认生成的文件在用户的家目录下.ssh/id_rsa.pub文件里面，复制全部内容； 粘贴到github，进入Account Settings，左边选择SSH Keys 测试ssh key是否成功，使用命令\"ssh -T git@github.com\" 配置Git的配置文件，username和email git config --global user.name \"your name\" //配置用户名 git config --global user.email \"your email\" //配置email git config --global core.editor vim //配置编辑器 git config --global color.ui true //配置颜色 总的来说Git的帮助文档很强大，忘记了git xx -h并且看看它的反馈提示基本就能解决； 0x0C Git config 待续... Reference git git Immersion 深入浅出 Git Git常用命令简记图 Visual Git Cheat Sheet","tags":"System","title":"Git Talk"},{"url":"https://pelucky.github.io/pages/2016/03/22/gitpages-pelican/","text":"这篇主要是总结下折腾 个人博客 的经验，前人已经刷了无数攻略，这个副本并不难，只是需要花时间。遇到问题时，Google始终是你最好的老师... 0x01 Requirement 搭建简单，维护备份方便 写博客方便，支持MD格式 模板美观大方，可以装B，不会丑的狗带 社区活跃，遇到问题可以抱大神大腿 0x02 Solution 主要是三大类解决方案： a. 商业化产品 Lofter CSDN b. 个人博客（CMS） Wordpress Durpal c. 静态页面 Pelican jekyll Ortopress 商业化产品首先不考虑，服务受提供商制约，用户体验有待提高，备份也很头疼，且没有折腾的意义... 使用过Wordpress，需要数据库等后面一套，略庞大，肯定需要独立空间，我懒... 自从 搭建一个免费的，无限流量的Blog----github Pages和Jekyll入门 之后，国内的个人博客就如雨后春笋，资料大把，原理类似... Static Site Generators 记录了github中各个开源的静态网站生成器star的情况，排名前五的是jekyll(Ruby)、Octopress(Ruby)、Hexo(Javascript)、Hugo(Go)、Pelican(Python) Jekyll Jekyll在Github上有20000+stars，远远领先于第二名的关注度，笔者没用过ruby，且国内ruby源被GFWfuck后，设置淘宝源各种蛋疼...遂放弃 Ortopress同理，但是看到别人做的效果挺好的就关注了下： 陋室 0x03 Pelican 笔者使用Python，并且之前接触过Pelican，考虑了一下就选择了最熟悉的Pelican,毕竟它叫 Pel I Can ... 1.Introduce pelican是一个用python生成的静态站点生成器。具有以下特点： 支持Markdown和reStructuredText格式； 可以使用简单的命令生成文件； 具有简单易用的版本控制系统； 完全静态，可在任何地方输出； 2.Setup 安装pelican pip install pelican Markdown 如有印刷格式上的需要，还需要安装typogrify pip install typogrify 3.Usage pelican-quickstart创建站点到/var/www/pelican/，根据脚本提示配置参数 a.站点结构 yourproject/ ├── content │ └── (pages) ├── output ├── develop_server.sh ├── fabfile.py ├── Makefile ├── pelicanconf.py # Main settings file └── publishconf.py # Settings to use when ready to publish b.文档内容 pelican支持三种格式：reStructuredText、markdown以及AsciiDoc reStructuredText要求文件后缀为.rst，并且源文件格式如下： My super title ############## :date: 2010-10-03 10:20 :modified: 2010-10-04 18:40 :tags: thats, awesome :category: yeah :slug: my-super-post :authors: Alexis Metaireau, Conan Doyle :summary: Short version for index and feeds This is the content of my super blog post. Markdown要求文件后缀为.md, .markdown, .mkd, 或 .mdown，并且源文件格式如下： Title : My super title Date : 2010 - 12 - 03 10 : 20 Modified : 2010 - 12 - 05 19 : 30 Category : Python Tags : pelican , publishing Slug : my - super - post Authors : Alexis Metaireau , Conan Doyle Summary : Short version for index and feeds This is the content of my super blog post . 还支持翻译、语法高亮、内置内容（模板）、从其他站点导入等功能； c.输出和启动 编辑好Markdown或reStructuredText文件后，pelican会将内容转换为静态html格式，输出到output中 pelican /path/to/your/content/ [-s path/to/your/settings.py] 启动服务器 cd output python -m SimpleHTTPServer #python2 python -m http.server #python3 打开浏览器http://192.168.1.112:8000/，预览效果； d.配置主题 Pelican支持大量的开源主题，GitHub上的pelican-themes项目有几十套主题，大部分都带了效果预览图。可以从里面挑一个喜欢的主题样式来使用。还有一个更方便的挑选主题的方式，直接打开 pelicanthemes 挑选（加载略慢）。一个网页里就列出了几乎所有的主题。该博客使用pelican-bootstrap3主题，并在这套主题的基础上进行了一些定制。选定好喜欢的主题后，从GitHub上下载下来所有的主题，安装主题： mkdir pelican cd pelican git clone https://github.com/getpelican/pelican-themes.git pelican-themes -i pelican-bootstrap3 然后在pelicanconf.py里通过下面代码指定博客主题： THEME = 'pelican-bootstrap3' 通常的做法是，选中一个自己喜欢的主题后，会进行一些定制。Pelican使用Jinja2来配置主题。一个主题的典型结构如下： ├── static │ ├── css │ └── images └── templates ├── analytics.html // 这是Google Analytics的代码 ├── archives.html // 这个是博客归档页面的模板 ├── article.html // 这个是博客正文的显示模板 ├── base.html // 这个是所有页面的父类模板，即所有页面都引用这个页面。比如网页导航栏啊之类的，都定义在这里 ├── categories.html // 所有博客文章的分类列表 ├── category.html // 某个博客分类的文章列表模板 ├── index.html // 主页 ├── page.html // 分页显示的模板 ├── tag.html // 某类标签下的文章列表 └── tags.html // 所有的标签列表页面模板 稍微有点Jinja的知识加上一些HTML和CSS的知识，就可以自己定义主题了。 e.配置插件 插件同主题类似，到github上down下来,虽然大部分插件都是全主题可用的,但是也存在好用与否的问题, 有些插件在原生主题上就需要自己改base.css才能用,所以尽量配套选,避免麻烦. git clone --recursive https://github.com/getpelican/pelican-plugins 将需要安装的插件添加到pelicanconf.py文件中，新版本将关键字改为PLUFIN_PATHS以及列表的形式。 PLUGIN_PATHS = [u\"pelican-plugins\"] PLUGINS = [u\"sitemap\", u\"tag_cloud\", u\"gzip_cache\", u\"related_posts\", u\"tipue_search\", u\"pelican-toc\"] tag_cloud, related_posts, gzip_cache参考手册设置即可 sitemap Pelican的sitemap插件可以导出站点地图，Google Webmaster是Google的站长工具，方便Google收录博客： a. 在pelicanconf.py中添加sitemap，同时别忘了设置SITEURL，否则生成的sitemap.xml不正确 SITEURL = u'https://pelucky.github.io' SITEMAP = { \"format\": \"xml\", \"priorities\": { \"articles\": 0.7, \"indexes\": 0.5, \"pages\": 0.3, }, \"changefreqs\": { \"articles\": \"monthly\", \"indexes\": \"daily\", \"pages\": \"monthly\", } } b. 登录 Google Webmasters ,注册博客并测试sitemap，测试通过后提交，过段时间就可以查看Google已经收录了博客。 亦可以选择\"Google抓取方式\"，手动提交索引；抓取的结果在\"抓取统计信息\"页面中查看，参考 关于我们的统计信息和数据 对于sitemap不熟悉的可以参考Google提供的 创建和提交站点地图 同样可以添加robots.txt用于告知Google抓取的内容，参考 了解 robots.txt 文件 tag_cloud 这个应该是必装的，否则右侧tag选项永远显示为空，在pelicanconf.py中添加： DISPLAY_TAGS_ON_SIDEBAR = True TAGS_URL = \"tags.html\" tag_cloud = True pelican-toc 添加Table of Contents，即可显示文章的目录，需要自行下载到pelican-plugins，参考 pelican-toc ，自带的extract_toc没这个方便... 在配置文件中添加： PLUGINS = ['pelican-toc'] TOC = { 'TOC_HEADERS' : '&#94;h[1-6]', # What headers should be included in the generated toc # Expected format is a regular expression 'TOC_RUN' : 'true' # Default value for toc generation, if it does not evaluate # to 'true' no toc will be generated } 在模板文件中添加，可以添加到文章最上面或(article.html)sidebar处： {% if article.toc %} {{ article.toc }} {% endif %} f.Google Analytics 去 Google Analytics 申请账号，会要求检验你拥有该站点的所有权，需要下载googlexxxx.html，上传并点击该链接来确认。记下跟踪ID。 在pelicanconf.py添加 GOOGLE_ANALYTICS = u'跟踪ID' 之后即可到Google Analytics的控制台查看访问情况； g.一键Github 若要一键上传到Github，需要修改Makefile脚本两处地方： publish : $( PELICAN ) $( INPUTDIR ) -o $( OUTPUTDIR ) -s $( CONFFILE ) $( PELICANOPTS ) ...... github : publish cd $( OUTPUTDIR ) ; git add . ; git commit -am 'Update pages' ; git push 以后写完文章在Pelican目录下执行make github就可以一键部署了。 h.取消代码中红框 参考： 修复pelican代码中红框 在使用Markdown的代码块时，如果代码中有汉字或者按规定书写错误的代码，则生成的HTML文件中错误的代码会有红框框住，output/theme/pygment.css文件中定义了该样式，注释或者删除掉。 .err { border: 1 px solid #FF0000; } 由于output中的内容每次都会生成，故需要把模板中的pygment.css进行更换，如果之前使用了 pelican-themes -i pelican-bootstrap 安装，则一般会在如下位置，直接vim修改模板中的pygment.css： pel@debian:~/pelican$ pelican-themes -p /usr/local/lib/python2.7/dist-packages/pelican/themes i.评论系统 在 Disqus 上申请一个站点，记牢Shortname(不需要加后缀)，评论系统加载起来有点慢，国内也可以使用多说。 在pelicanconf.py添加 DISQUS_SITENAME = 'Shortname' j.插入图片 有两种方法: 一种是使用云存储，设置为公开图片，直接链接过来，如 Picasa 来维护图片,推荐使用云图床； ![Test Cloud img](https://lh3.googleusercontent.com/-rBvjY3F2wEU/VvD3yZ9T-1I/AAAAAAAAAVc/LsPcb3CIxtomUcXq5aVKj27qSrI4OserwCCo/s400-Ic42/3d94dcb44aed2e730566c2068601a18b86d6fa7f.jpg) 另一种使用本地图片， 参考 ,但Github有图片容量限制。content目录下建立一个 images目录 然后在 pelicanconf.py 中添加: STATIC_PATHS = [\"images\"] 在文章中引用图片,路径要设置为本文件与图片文件中的相对路径，如果文件路径变更了，就需要修改图片的相对路径，那个真蠢...可 参考 ： ! [ Test img ](.. / .. / .. / .. / .. / .. / images / test . jpg ) k.设置域名 待续... l.站内搜索 站内搜索有两种解决方案，一种是采用Google的站内搜索，另一种是使用静态搜索引擎； Google站内搜索 由于Bootstrap支持Tipue Search，故没怎么折腾Google站内搜索，参考： pelican建站攻略补充（站内搜索，和标签云） Tipue Search静态搜索引擎 原理就是每次生成静态网站的时候，同时会生成一个JSON格式的索引文件，前端加载一个检索入口即可搜索网站内容，比较适合中小型的静态网站； PLUGINS = [u\"tipue_search\"] Tipue Search DIRECT_TEMPLATES = (('index', 'tags', 'categories', 'archives', 'search',)) SEARCH_URL = '/search' Tips: 从pelican-plugins下git下来的Tipue Search有bug，搜索出来的URL会显示undefined，参考 此处 ，将Tipue_Search更新至5.0即可，具体更新的方法参考 Site search with Tipue for Pelican ，要注意查看template/search.html中的路径； m.从WordPress迁移到Pelican 导出WordPress数据；在 WordPress 后台 -> 工具 -> 导出。即可导出并下载包含全部文章、页面、评论、自定义栏目、分类目录和标签的 xml 文件。 将xml转成Markdown；使用 exitwp 自动处理xml文件。下载后将导出的 xml 放入 wordpress-xml 目录中，运行 python exitwp.py 即可将 xml 转成 Markdown。 需要注意的是转换出的文件注释部分，关于Tags，Category，Date等Meta部分需要按Pelican的形式进行格式调整，以便被Pelican解析，其实还是有点工作量的... 看文档发现，有pelican-import可以直接从wordpress导入， 参考 n.URL配置 默认的URL太low了，可以更优雅...但要注意修改后本地图片的相对路径需要该. 打开pelicanconf.py配置文件，添加如下，具体配置请参见 官方文档 。 ARTICLE_URL = 'pages/{date:%Y}/{date:%m}/{date:%d}/{slug}/' ARTICLE_SAVE_AS = 'pages/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' o.更换字体 Pelican默认的字体使用了Google的字体服务，会导致加载速度巨慢，更改国内的源或将字体文件放到github上 #static/css/目录下css文件中,例如gumby.css @import url ( // fonts . googleapi . com / css ? family = Open + Sans : 400 , 300 , 600 , 700 ); #替换为 @import url ( // fonts . useso . com / css ? family = Open + Sans : 400 , 300 , 600 , 700 ); 如何创建github-page、git使用就不介绍了... 之后的折腾就都来自Pelican docs Bootstrap3 很值得看，里面介绍了模板支持的功能 Blog Source code 感谢林无知的Nono熊 Reference Pelican docs GitPages 使用Pelican搭建博客系统 使用Pelican + Github Pages搭建个人博客 一步一步打造Geek风格的技术博客 教你将博客从WordPress迁移到Pelican Pelican＋Github博客搭建及快速进阶","tags":"System","title":"Pelican札记"},{"url":"https://pelucky.github.io/pages/2016/01/13/hello-world/","text":"Mark! First Blood... 比该文章早的是从\"局域网\"中的wordpress迁移过来的,故此为第一篇...","tags":"Life","title":"Hello world"},{"url":"https://pelucky.github.io/pages/2015/10/10/switch-snmp/","text":"最近一直在研究使用zabbix监控整个系统，服务器的简单，直接套用模板即可，交换机和路由器无法安装zabbix agentd，故需要使用snmp，简单介绍下各类交换机打开snmp的方法： SNMP SNMP有一个树状结构的oid，每个树端点为一个值，比如CPU的负载 => 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.5 故需要查询某值时只需要输入对应的oid即可。 服务器端 服务器端需要zabbix在编译时添加对snmp的支持，除此之外还需要安装net-snmp和net-snmp-utils，安装这两个之后可以使用snmpwalk命令检测交换机是否设置正确； 服务器和所需要管理的交换机串连在一起，实现带内管理。 交换机端 交换机方面的设置整体思路都是相同的： 打开telnet登录->设置交换机参数->设置snmp->服务器端测试。 简单介绍下碰到的几类交换机： huawei S2326 <Quidway>system-view Enter system view, return user view with Ctrl+Z. [Quidway]snmp-agent [Quidway]snmp-agent local-engineid 800063A203000FE207F2E0 //不需要，自己会生成 [Quidway]snmp-agent community read public [Quidway]snmp-agent sys-info version all [Quidway]snmp-agent target-host inform address udp-domain 192.168.18.1 udp-port 161 params securityname public v2c [Quidway]snmp-agent trap enable basetrap 注释： 1. udp-domain 192.168.18.1 //zabbix服务器ip地址 2. udp-port 161 //监听端口 ，默认是udp 161端口 3. snmp-agent community read public //社团名称public DCN DCS-4500（指令类似思科） enable configure terminal snmp-server enable snmp-server securityip 192.168.18.1 snmp-server community ro public snmp-server enable traps 交换机设置完成后，有两种方法测试，第一种使用snmpwalk指令；第二种使用getif软件； snmpwalk snmpwalk的基本命令模式: snmpwalk -v 2c -c hidecode 192.168.0.4 .1.3.6.1.2.1.1.5.0 -v 代表SNMP的版本号，目前只有3种 1 2c 3 -c 代表访问的SNMP CODE 后面跟上IP地址 空格后跟上要查询的OID即可，如果不输入OID他就会探索所有的OID出来~ 华为设备的oid： CPU => 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.5 内存 => 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.7 设备温度 => 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.11 系统运行时间 => 1.3.6.1.2.1.1.3.0 设备名称 => 1.3.6.1.2.1.1.5 端口描述 => 1.3.6.1.2.1.31.1.1.1.18 流入流量 => 1.3.6.1.2.1.2.2.1.10 流出流量 => 1.3.6.1.2.1.2.2.1.16 端口状态 => 1.3.6.1.2.1.2.2.1.8 输出结果： SNMPv2-MIB::sysName.0 = STRING: S2326-100-8L-2P-5 getif 一款可以测试snmp的windows下的软件，它可以获取所有的oid,使用方法 在parameters->host name ->点击下方的start即可以看到设备的最基本的信息； 选择interfaces->start即可看到所有的接口信息； 选择MBrowser->输入对应的oid->start即可获取该值结果。不输入则会全部显示；","tags":"Network","title":"交换机开启SNMP"},{"url":"https://pelucky.github.io/pages/2015/09/15/bitnami-move/","text":"前文有介绍，发现bitnami这个大套件后，就顺手搭了三个系统： 用于代码管理的gitlab 用于工作管理的redmine 用于知识共享的dokuwiki bitnami的好处之前已经提过，一键式安装，所有组件都子提供一份。但缺点也很明显，扩展、升级、备份略微蛋疼... 原因 迁移的原因很简单，之前对于服务器分区，将/var用作存储数据，将/usr用作存储软件，故在安装bitnami的时候，下意识的就将三个平台放到/usr上了，后来一查看空间，/usr总共才分了30G，对于dokuwiki时肯定不够的，故决定迁移； 这个问题也说明了业务数据和逻辑实现分离的重要性，同时也是bitnami的弊端，给懒人安装上的便利，同时带来维护上的麻烦； 解决思路 这算是总结之后的思路： 去bitnami的官方网站和bbs查看是否有迁移的方法；查到了备份和还原的方法；以及查看到了bitnami平台的文件结构，至少需要备份./XXX/apps/中的内容，这一般就是特定系统的文件。对于dokuwiki使用文本进行保存，就不需要备份数据库了，否则需要将数据库中的内容备份； 在新的位置重新安装一遍dokuwik；因为只是迁移，故只要修改为正确的路径即可，其他的与原系统的相同；停止新的dokuwiki服务； 停止方法是进入到bitnami系统的目录，运行./ctlscript.sh stop。该脚本就是负责整个bitnami系统的启停； 停止老的dokuwiki系统（当然在安装新的dokuwiki时就应该停止老系统了）；将老的dokuwiki中的./apps/dokuwiki中的内容全部都覆盖到新的对应的位置，要保留文件权限，同时强制复制： TIPS: 由于CentOS在启动脚本中已将alias cp=cp -i，故遇到重复的文件，会强制询问你，所以可以先unalias cp，否则会询问很多次； cp -rfvp dokuwiki/ /var/opt/dokuwiki-20140929d-0/apps/ 替换更新后的文件中的路径参数；因为dokuwiki中有许多配置文件会涉及到文件系统路径的问题，故需要更新路径； TIPS： 最开始想到使用sed替换，但是sed遇到需要转义的字符就会嗝屁；最后敲定使用rpl工具，需要自己下载，但是功能很强大； rpl -vR \"usr/dokuwiki-20140929-0\" \"var/opt/dokuwiki-20140929d-0\" ./dokuwiki/ 启动新的dokuwiki系统，查看是否有问题。运行./ctlscript.sh start；（如果之前复制没有使用相同的权限，则启动可能无法写缓存） 之前绕了很大一圈：最初的思路是直接将整个系统复制过来，再对所有文件全部进行路径配置替换，但是系统会报错，故作罢。还是不能像绿色软件那样移动自如；","tags":"System","title":"bitnami之迁移"},{"url":"https://pelucky.github.io/pages/2015/09/14/setup-django/","text":"主要是局域网蛋疼，无pip，yum中不包含Django，故只能手动安装 首先查看Python版本，CentOS6.5自带Python2.6，没戏，需要重新安装2.7以上版本； 下载Python2.7.10，源码安装，三部曲走起... 安装Django，提示需要安装setuptools，去下载，从头来； 安装setuptools，外网只需要一个指令，即可自动安装，内网蛋疼， /usr/local/python-2.7.10/bin/python setup.py install ，提示如下： Traceback (most recent call last): File \"setup.py\", line 171, in <module> dist = setuptools.setup(**setup_params) File \"/usr/local/python-2.7.10/lib/python2.7/distutils/core.py\", line 151, in setup dist.run_commands() File \"/usr/local/python-2.7.10/lib/python2.7/distutils/dist.py\", line 953, in run_commands self.run_command(cmd) File \"/usr/local/python-2.7.10/lib/python2.7/distutils/dist.py\", line 972, in run_command cmd_obj.run() File \"/usr/local/src/setuptools-18.3.1/setuptools/command/install.py\", line 67, in run self.do_egg_install() File \"/usr/local/src/setuptools-18.3.1/setuptools/command/install.py\", line 109, in do_egg_install self.run_command('bdist_egg') File \"/usr/local/python-2.7.10/lib/python2.7/distutils/cmd.py\", line 326, in run_command self.distribution.run_command(command) File \"/usr/local/python-2.7.10/lib/python2.7/distutils/dist.py\", line 972, in run_command cmd_obj.run() File \"/usr/local/src/setuptools-18.3.1/setuptools/command/bdist_egg.py\", line 222, in run dry_run=self.dry_run, mode=self.gen_header()) File \"/usr/local/src/setuptools-18.3.1/setuptools/command/bdist_egg.py\", line 463, in make_zipfile z = zipfile.ZipFile(zip_filename, mode, compression=compression) File \"/usr/local/python-2.7.10/lib/python2.7/zipfile.py\", line 736, in __init__ \"Compression requires the (missing) zlib module\" 简而言之就是没有zlib，网上查找再三，找到解决方法： yum install zlib yum install zlib-devel 再重新编译python2.7，再三部曲 1. 安装setuptools，成功； 2. 安装django，成功； 3. 如此蛋疼的问题，谁会想得到....","tags":"System","title":"安装Django小记"},{"url":"https://pelucky.github.io/pages/2015/08/03/huawei-s2300-port-mirror/","text":"wireshark抓取局域网中的包，有三种方法： 交换机换成集线器，也就是交换性网络换成共享性网络，会有广播风暴等缺点，现在普通的交换机都已经是交换性网卡了，这个方案肯定不可行； 交换机中做端口镜像。这个可以有； 做man-in-the-middle攻击。现在的大部分主机都会安装防火墙和杀软，一进行中间人攻击，可恶的360就会报警，但是手机平板之类的就另说了... 交换机为Huawei s2326 ，查了下交换机手册，做了下端口镜像： <Huawei-s2326>:sys //进入交换机 [Huawei-s2326]:observing-port 1 interface Ethernet 0/0/24 //设置观察端口 [Huawei-s2326]:interface Ethernet 0//0/1 //进入被镜像端口 [Huawei-s2326]:port-mirroring to observe-port 1 both //设置双向镜像 打开wireshark，即可抓包分析网络数据。","tags":"Network","title":"Wireshark抓包测试--Huawei s2300 端口镜像"},{"url":"https://pelucky.github.io/pages/2015/08/03/gitlab-setup/","text":"习惯了外网使用github管理代码，局域网中依旧没有： 简单说下安装使用 前期调研 两大选择SVN或者git，一直没有用过SVN，如果搭建内网SVN估计难度较大，故选择了git； 开源git方案最常见的就是gitlab 关于gitlab gitlab是基于ruby on rails框架； 先去官方网站看了说明，查看有两种安装： 一种是每种服务自行安装，包括mysql、appache或nginx、ruby等，要解决依赖性等问题，相对复杂； 另一种官网提供了脚本，一键运行脚本，再下载对应的安装包，如rpm或deb包； 原本计划为第二种方案，但是查看脚本，有curl https://xxx，发现需要下载外网文件，安装中中断，后自行下载暂未安装； 再查找解决方法的时候，发现 bitnami ，一个为开源软件提供一键安装的支持，bitnami-gitlab就是解决bitnami问题，安装方法很简单： 下载对应64位的run安装包，运行，设置参数即可；","tags":"System","title":"gitlab 安装使用"},{"url":"https://pelucky.github.io/pages/2015/08/02/ibm-x3650-m3-setup-linux/","text":"回来折腾服务器，主要的问题是没接触过EFI，不了解EFI的工作原理，故重装服务器折腾了很久，服务器重启又是一个长等待，简单介绍下相关原理： 原引导流程 BIOS+MBR: 具体可以参考鸟哥linux，由于BIOS大小的64KB限制，只能分4个主分区，每个分区的大小不能超过2T，这个是硬伤，随着磁盘存储容量的升级，上T的硬盘都不是问题； 现引导流程 EFI+GPT: Intel提出的，主要就是为了解决上面的问题，现在预装windows系统、Mac系统的都已经采用了EFI的引导方式。EFI的另一个优点是可以确保安装授权的操作系统（MS极力推广的原因） 关于系统 CentOS在6.3之前需要下载不同的IOS，对于EFI的版本需要下载CentOS 6.3 - EFI版本，对于BIOS的则需要下载普通版，6.3之后的已经不用再区分版本了，两个都可以兼容； 关于服务器 主板支持EFI引导方式的服务器需要在BIOS中设置为EFI，当需要切换回传统引导方式时则需要切换成Legacy 关于分区 设置为EFI引导方式安装系统时，需要创建/boot/efi（暂时未安装成功） 设置BIOS引导方式安装系统则正常安装即可。","tags":"System","title":"IBM x3650 m3 安装Linux小记"},{"url":"https://pelucky.github.io/pages/2015/08/02/centos-6-5-update-http/","text":"笔者以前不能连接互联网，故需要自己内建update源... 局域网内部未找到CentOS源，故决定自己做一个，查了下教程，不难，简单写一下： 如果只是想使用的话，则只看下面客户端配置即可，要求是CentOS6.5 64bit。 服务器端配置 a. 准备好CentOS-6.5DVD1和DVD2中的文件，通过winSCP或lrzsz上传到服务器上； b. 开启http服务，apache、Nginx均可 c. 将DVD1中的内容全部拷贝到上面的文件夹中，将DVD2中Packages中的文件全部拷进去 mkdir /var/www/html/yum/CentOS-6.5/ d. 合并DVD2中的Packages/TRANS.TBL到DVD1中并排序，主要是cat进入后再sort，没用过这个方法，记录下 cat dvd2/Packages/TRANS.TBL >> dvd1/Packages/TRANS.TBL mv dvd1/Packages/{TRANS.TBL.BAK,TRANS.TBL.BAK} sort dvd1/Packages/TRANS.TBL.BAK >dvd1/Packages/TRANS.TBL rm -rf dvd1/Packages/TRANS.TBL.BAK e. 接下来使用安装createrepo病创建软件仓库： rpm -ivh Packages/deltarpm-3.5-0.5.20090913git.el6.x86_64.rpm rpm -ivh Packages/python-deltarpm-3.5-0.5.20090913git.el6.x86_64.rpm rpm -ivh Packages/createrepo-0.9.9-18.el6.noarch.rpm f. 使用createrepo命令将所有安装包加载进入到软件仓库中： createrepo -v /var/www/html/yum/CentOS-6.5/Packages/ 客户端配置 使用vim修改/etc/yum.repos.d/CentOS-Base.repo的文件： # Made by pel for yum update [base] name=myrepo baseurl=http://192.168.1.10/yum/CentOS-6.5/Packages enabled=1 gpgcheck=0 #release updates [updates] name=myrepo baseurl=http://192.168.1.10/yum/CentOS-6.5/Packages gpgcheck=1 enabled=1 gpgcheck=0 #packages used/procduced in the build but not released [addons] name=myrepo baseurl=http://192.168.1.10/yum/CentOS-6.5/Packages enabled=1 gpgcheck=0 #additional packages that may be useful [extras] name=myrepo baseurl=http://192.168.1.10/yum/CentOS-6.5/Packages enabled=1 gpgcheck=0</blockquote> 查看效果 yum list 即可看到可安装的软件源","tags":"System","title":"CentOS 6.5 64bits 自建内部http源"}]}